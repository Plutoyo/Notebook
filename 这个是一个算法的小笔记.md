## 这个是一个算法的小笔记

离17号考试还有14天

每日需要完成一道

### **201312-3** 最大的矩形 

使用单调栈算法,维护一个单调递增的栈来保持策略的高度有效性

### **202009-3** 点亮数字人生 

模拟,使用了拓扑排序来保证先后循序,

学习了使用for(auto &i:xxx)来对STL进行代码简洁化

比如set,vactor,map,list等等都可以

### 一些小技巧学习
测试一下运算符重载来排序

```
bool operator <(const node&a,const node&b)
{
	if(a<b) return 1;
	else return 0;
}
sort(A,A+5);
```

可以直接使用sort(A,A+5)来直接排序,在algorithm中,默认是升序,通过改变符号来变成降序
或者加入第三个参数

```
bool CMP(const node&a,const node&b)
{
	if(a<b) return 1;
	else return 0;
}
sort(A,A+5,CMP);
```

unique()可以对数组进行去重,必选先排序,他是将重复的元素放到数组的后面,返回最后一个不重复的下一个,因此unique(a,a+5)-a得到不重复的数

``` 快速幂
快速幂
//计算X^n mod m
#define LL long long
LL powerMod(LL X,LL n,LL m)
{
	LL res=1;
	while(n>0)
	{
		if(n&1) res=(res*X)%m
		x=(x*x)%m
		n>>=1;
	}
	return res;
}
```


``` 快速乘法取模算法
//快速乘法取模算法
LL qmol(LL X,LL Y,LL mod)
{
	LL res=0;
	while(y)
	{
		if(Y&1) res=(res+X)%mod;
		X= X * 2 % mod;
		Y>>=1;
	}
	return res;
}
```

### 调试小技巧

在开头写上#define DEBUG

然后在代码中间插入

```
#ifdef DEBUG
	cout << "DEBUG" << endl;
#endif // DEBUG
```

这样如果注释掉开头的#define DEBUG,那么这一段中间的代码就不会执行