## 这个是一个算法的小笔记

离17号考试还有14天

每日需要完成一道

### 201312-3 最大的矩形 

使用单调栈算法,维护一个单调递增的栈来保持策略的高度有效性

### 202009-3 点亮数字人生 

模拟,使用了拓扑排序来保证先后循序,

学习了使用for(auto &i:xxx)来对STL进行代码简洁化

比如set,vactor,map,list等等都可以

### 一些小技巧学习
测试一下运算符重载来排序

```c++
bool operator <(const node&a,const node&b)
{
	if(a<b) return 1;
	else return 0;
}
sort(A,A+5);
```

可以直接使用sort(A,A+5)来直接排序,在algorithm中,默认是升序,通过改变符号来变成降序
或者加入第三个参数

```c++
bool CMP(const node&a,const node&b)
{
	if(a<b) return 1;
	else return 0;
}
sort(A,A+5,CMP);
```

unique()可以对数组进行去重,必选先排序,他是将重复的元素放到数组的后面,返回最后一个不重复的下一个,因此unique(a,a+5)-a得到不重复的数

``` c++
快速幂
//计算X^n mod m
#define LL long long
LL powerMod(LL X,LL n,LL m)
{
	LL res=1;
	while(n>0)
	{
		if(n&1) res=(res*X)%m
		x=(x*x)%m
		n>>=1;
	}
	return res;
}
```


``` c++
//快速乘法取模算法
LL qmol(LL X,LL Y,LL mod)
{
	LL res=0;
	while(y)
	{
		if(Y&1) res=(res+X)%mod;
		X= X * 2 % mod;
		Y>>=1;
	}
	return res;
}
```

### 调试小技巧

在开头写上#define DEBUG

然后在代码中间插入

```c++
#ifdef DEBUG
	cout << "DEBUG" << endl;
#endif // DEBUG
```

这样如果注释掉开头的#define DEBUG,那么这一段中间的代码就不会执行

### 201609-4 交通规划

单源最短路径Dijkstra,维护一个优先队列来每次出离出发点最近的点

```C++
void dj()
{
	fill(d, d + sizeof(d)/sizeof(int), MAX_INT);
	fill(cost, cost + sizeof(cost) / sizeof(int), MAX_INT);
	d[1] = 0;
	q.push(node(1,0));
	//cost[1] = 0;
	while (!q.empty())
	{
		node k = q.top();
		q.pop();
		int u = k.v;
		if (vis[u]) continue;
		vis[u] = 1;
		//u是选出节点的编号
		for (auto zz : G[u])//G[u]代表从u号节点出发
		{
			//v是选出节点的相邻的点
			int v = zz.v;
			if (vis[v]) continue;
			//zz.dis代表u到v的距离
			if (d[u] + zz.dis < d[v])
			{
				d[v] = d[u] + zz.dis;
				cost[v] = zz.dis;
				q.push(node(v, d[v]));
			}
			else if (d[u] + zz.dis == d[v])
			{
				cost[v] = min(cost[v], zz.dis);
			}
		}
	}
}
```

### Dev调试STL技巧

比如vector<int> v

在调试的时候输入*(&v[0])@length,就能看到整个数组了

加一句 template class vector<int>;

可以使用*(&v[0])@v.size();

对于二维的vector数组,好像只能使用*(&pp\[0\]\[0\]@pp[0].size()来查看单列的

```C++
*(&pp[0][0])@pp[0].size()
```

### Dev调试Bug导致endl卡住解决办法

使用宏定义#define endl "\n"即可

### 优先队列

优先队列使用bool operator <(const node &a,const node &a) 来进行,并且top是指向大的值,所以如果是需要最小的值需要将顺序排成降序.

### 201503-4 网络延时

学习使用了树形DP,求一颗树的直径,即最长链长度,维护两个数组,维护D1[i],D2[i],即储存了最长链与次长链

ans=max(ans,D1[i]+D2[i]),使用深度优先

``` C++
void dfs(int k, int pre)
{
	for (auto i : G[k])
	{
		if (i == pre) continue;
		dfs(i, k);
		if (D1[i] + 1 > D1[k])
		{
			D2[k] = D1[k];
			D1[k] = D1[i] + 1;
		}
		else if (D1[i] + 1 > D2[k])
		{
			D2[k] = D1[i] + 1;
		}
	}
	ans = max(ans, D1[k] + D2[k]);
}
```

相比较于其他人冗杂的代码,使用vector数组储存邻接边的形式可读性强,并且如果不维护一个visited数组,就要使用一个pre变量,避免无限往返

### 刷LeetCode

思考20分钟,若完全无思路就去学习

### 动态规划

+ [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

​		因为要求是最大的连续子序列,所以一定需要维护的f[i]第i位要在数组中,不然没办法递推下去,这是动态规划需要考虑的问题

+ [面试题 17.16. 按摩师](https://leetcode-cn.com/problems/the-masseuse-lcci/) 

​			按摩师需要进行状态转移的维护,因为不能连续的接受预约,所以需要对上一次的状态进行维护,一个是第i次接受了预约,一个是第i次		没有接受预约,要分清状态的情况来进行讨论,联想到之前看到的状态压缩dp,他使用了二进制位来表示不同的状态,这里的状态较少,所		以使用二维数组就能维护,第一维代表到第i的最大预约时间,第二个维度0和1分别代表了第i次接受预约和第i次不接受预约.如果是有更		多的状态,在第二维可以开更大的数组来表示状态,但是如果状态实在是太过于多,就可以考虑状态压缩的二进制位来表示~~(我好菜不		会位运算)

> 算法改良:
>
> 由于只需要维护2个状态0与1,所以不需要开数组,t=0,0=max(0,1);1=t+nums[i];

+ #### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

  动态规划只能考虑走一步的情况,如果必须要考虑多步可能就会出现错误

+ #### [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

  ~~万物基于DP(bushi)~~这道题也能DP是没想到的,通过对字符串进行DP

  使用 **f( i , j )** 表示从第 i 个位置往后, **j** 字符出现的位置
  $$
  f(i,j)=
  \begin{cases}
  	i & \text{j=t[i]}\\
  	f(i+1,j) & \text{j$\neq$t[i]} 
  \end{cases}
  $$
  因为是全是小写字母,所以使用第二维来表示ASCII码,因为全是小写字母,所以只需要开26大小,使用c-'a'来映射

  对于检查的时候,使用

  ```C++
  for(int i=0;i<s.size();i++)
  {
      if(dp[k][s[i]-'a']!=t.size())
      {
          k=dp[k][s[i]-'a']+1;
          //因为如果dp[k][s[i]-'a']满足条件,那么这个里面就存的是从k开始满足条件的字符,所以当这个字符匹配到之后,需要往后跳转一位.
          cout<<k<<' ';
      }
      else return 0;
  }
  return 1;
  ```

  